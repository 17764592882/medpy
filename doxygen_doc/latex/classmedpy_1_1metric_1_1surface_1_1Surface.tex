\hypertarget{classmedpy_1_1metric_1_1surface_1_1Surface}{
\section{medpy.metric.surface.Surface Class Reference}
\label{classmedpy_1_1metric_1_1surface_1_1Surface}\index{medpy::metric::surface::Surface@{medpy::metric::surface::Surface}}
}


Computes different surface metrics between two 3D-\/images contain each an object.  




Inheritance diagram for medpy.metric.surface.Surface:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=228pt]{classmedpy_1_1metric_1_1surface_1_1Surface__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for medpy.metric.surface.Surface:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=228pt]{classmedpy_1_1metric_1_1surface_1_1Surface__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classmedpy_1_1metric_1_1surface_1_1Surface_a46994eacbac664bc6d33d19bac6f7b2c}{\_\-\_\-init\_\-\_\-}
\begin{DoxyCompactList}\small\item\em Initialize the class with two binary images, each containing a single object. \end{DoxyCompactList}\item 
def \hyperlink{classmedpy_1_1metric_1_1surface_1_1Surface_aebdeff8c2d6391c37572e5a791ed40f8}{GetMaximumSymmetricSurfaceDistance}
\begin{DoxyCompactList}\small\item\em Computes the maximum symmetric surface distance, also known as Hausdorff distance, between the two objects surfaces. \end{DoxyCompactList}\item 
def \hyperlink{classmedpy_1_1metric_1_1surface_1_1Surface_a43fc6c5bbe3af05e886341fc3cd6e4a6}{GetRootMeanSquareSymmetricSurfaceDistance}
\begin{DoxyCompactList}\small\item\em Computes the root mean square symmetric surface distance between the two objects surfaces. \end{DoxyCompactList}\item 
def \hyperlink{classmedpy_1_1metric_1_1surface_1_1Surface_a908c895052fb4ae5d6e85b0eb74af561}{GetAverageSymmetricSurfaceDistance}
\begin{DoxyCompactList}\small\item\em Computes the average symmetric surface distance between the two objects surfaces. \end{DoxyCompactList}\item 
def \hyperlink{classmedpy_1_1metric_1_1surface_1_1Surface_aa1286d971da183a1763d0756d35c90bd}{GetMaskReferenceNn}
\item 
def \hyperlink{classmedpy_1_1metric_1_1surface_1_1Surface_a1ddfc188d4a3c2e7bf3d9347fdec8b14}{GetReferenceMaskNn}
\item 
def \hyperlink{classmedpy_1_1metric_1_1surface_1_1Surface_a56381bbc209cbd46954ebc49e38d266c}{GetMaskEdgePoints}
\item 
def \hyperlink{classmedpy_1_1metric_1_1surface_1_1Surface_a7248264eca680d9c4d327961fd04c8be}{GetReferenceEdgePoints}
\end{DoxyCompactItemize}
\paragraph*{}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classmedpy_1_1metric_1_1surface_1_1Surface_af49341603861561734d2f8cb6a612bd1}{ComputeContour}
\begin{DoxyCompactList}\small\item\em Uses a 18-\/neighbourhood filter to create an edge image of the input object. \end{DoxyCompactList}\end{DoxyCompactItemize}



\subsection{Detailed Description}
Computes different surface metrics between two 3D-\/images contain each an object. 

The surface of the objects is computed using a 18-\/neighbourhood edge detection. The distance metrics are computed over all points of the surfaces using the nearest neighbour approach. Beside this provides a number of statistics of the two images.

During the initialization the edge detection is run for both images, taking up to 5 min (on 512$^\wedge$3 images). The first call to one of the metric measures triggers the computation of the nearest neighbours, taking up to 7 minutes (based on 250.000 edge point for each of the objects, which corresponds to a typical liver mask). All subsequent calls to one of the metrics measures can be expected be in the sub-\/millisecond area.

Metrics defined in: Heimann, T.; van Ginneken, B.; Styner, M.A.; Arzhaeva, Y.; Aurich, V.; Bauer, C.; Beck, A.; Becker, C.; Beichel, R.; Bekes, G.; Bello, F.; Binnig, G.; Bischof, H.; Bornik, A.; Cashman, P.; Ying Chi; Cordova, A.; Dawant, B.M.; Fidrich, M.; Furst, J.D.; Furukawa, D.; Grenacher, L.; Hornegger, J.; Kainmuller, D.; Kitney, R.I.; Kobatake, H.; Lamecker, H.; Lange, T.; Jeongjin Lee; Lennon, B.; Rui Li; Senhu Li; Meinzer, H.-\/P.; Nemeth, G.; Raicu, D.S.; Rau, A.-\/M.; van Rikxoort, E.M.; Rousson, M.; Rusko, L.; Saddi, K.A.; Schmidt, G.; Seghers, D.; Shimizu, A.; Slagmolen, P.; Sorantin, E.; Soza, G.; Susomboon, R.; Waite, J.M.; Wimmer, A.; Wolf, I.; , \char`\"{}Comparison and Evaluation of Methods for Liver Segmentation From CT Datasets,\char`\"{} Medical Imaging, IEEE Transactions on , vol.28, no.8, pp.1251-\/1265, Aug. 2009 doi: 10.1109/TMI.2009.2013851 

Definition at line 44 of file surface.py.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmedpy_1_1metric_1_1surface_1_1Surface_a46994eacbac664bc6d33d19bac6f7b2c}{
\index{medpy::metric::surface::Surface@{medpy::metric::surface::Surface}!\_\-\_\-init\_\-\_\-@{\_\-\_\-init\_\-\_\-}}
\index{\_\-\_\-init\_\-\_\-@{\_\-\_\-init\_\-\_\-}!medpy::metric::surface::Surface@{medpy::metric::surface::Surface}}
\subsubsection[{\_\-\_\-init\_\-\_\-}]{\setlength{\rightskip}{0pt plus 5cm}def medpy.metric.surface.Surface.\_\-\_\-init\_\-\_\- (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{mask, }
\item[{}]{reference, }
\item[{}]{physical\_\-voxel\_\-spacing = {\ttfamily \mbox{[}1}, }
\item[{}]{mask\_\-offset = {\ttfamily \mbox{[}0}, }
\item[{}]{reference\_\-offset = {\ttfamily \mbox{[}0}}
\end{DoxyParamCaption}
)}}
\label{classmedpy_1_1metric_1_1surface_1_1Surface_a46994eacbac664bc6d33d19bac6f7b2c}


Initialize the class with two binary images, each containing a single object. 

Assumes the input to be a representation of a 3D image, that fits one of the following formats: 1. all 0 values denoting background, all others the foreground/object 2. all False values denoting the background, all others the foreground/object The first image passed is referred to as 'mask', the second as 'reference'. This is only important for some metrics that are not symmetric (and therefore not really metrics). 
\begin{DoxyParams}{Parameters}
{\em mask} & binary mask as an scipy array (3D image) \\
\hline
{\em reference} & binary reference as an scipy array (3D image) \\
\hline
{\em physical\_\-voxel\_\-spacing} & The physical voxel spacing of the two images (must be the same for both) \\
\hline
{\em mask\_\-offset} & offset of the mask array to 0,0,0-\/origin \\
\hline
{\em reference\_\-offset} & offset of the reference array to 0,0,0-\/origin \\
\hline
\end{DoxyParams}


Definition at line 74 of file surface.py.



\subsection{Member Function Documentation}
\hypertarget{classmedpy_1_1metric_1_1surface_1_1Surface_af49341603861561734d2f8cb6a612bd1}{
\index{medpy::metric::surface::Surface@{medpy::metric::surface::Surface}!ComputeContour@{ComputeContour}}
\index{ComputeContour@{ComputeContour}!medpy::metric::surface::Surface@{medpy::metric::surface::Surface}}
\subsubsection[{ComputeContour}]{\setlength{\rightskip}{0pt plus 5cm}def medpy.metric.surface.Surface.ComputeContour (
\begin{DoxyParamCaption}
\item[{}]{array}
\end{DoxyParamCaption}
)}}
\label{classmedpy_1_1metric_1_1surface_1_1Surface_af49341603861561734d2f8cb6a612bd1}


Uses a 18-\/neighbourhood filter to create an edge image of the input object. 

Assumes the input to be a representation of a 3D image, that fits one of the following formats:
\begin{DoxyItemize}
\item 1. all 0 values denoting background, all others the foreground/object
\item 2. all False values denoting the background, all others the foreground/object The area outside the array is assumed to contain background voxels. The method does not ensure that the object voxels are actually connected, this is silently assumed.
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em array} & a numpy array with only 0/N0\} or False/True values. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a boolean numpy array with the input objects edges 
\end{DoxyReturn}


Definition at line 295 of file surface.py.

\hypertarget{classmedpy_1_1metric_1_1surface_1_1Surface_a908c895052fb4ae5d6e85b0eb74af561}{
\index{medpy::metric::surface::Surface@{medpy::metric::surface::Surface}!GetAverageSymmetricSurfaceDistance@{GetAverageSymmetricSurfaceDistance}}
\index{GetAverageSymmetricSurfaceDistance@{GetAverageSymmetricSurfaceDistance}!medpy::metric::surface::Surface@{medpy::metric::surface::Surface}}
\subsubsection[{GetAverageSymmetricSurfaceDistance}]{\setlength{\rightskip}{0pt plus 5cm}def medpy.metric.surface.Surface.GetAverageSymmetricSurfaceDistance (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}}
\label{classmedpy_1_1metric_1_1surface_1_1Surface_a908c895052fb4ae5d6e85b0eb74af561}


Computes the average symmetric surface distance between the two objects surfaces. 

\begin{DoxyReturn}{Returns}
average symmetric surface distance in millimeters
\end{DoxyReturn}
For a perfect segmentation this distance is 0.

Metric definition: Let $S(A)$ denote the set of surface voxels of $A$. The shortest distance of an arbitrary voxel $v$ to $S(A)$ is defined as: \[ d(v,S(A)) = \min_{s_A\in S(A)} ||v-s_A|| \] where $||.||$ denotes the Euclidean distance. The average symmetric surface distance is then given by: \[ ASD(A,B) = \frac{1}{|S(A)|+|S(B)|} \left( \sum_{s_A\in S(A)} d(s_A,S(B)) + \sum_{s_B\in S(B)} d(s_B,S(A)) \right) \] 

Definition at line 218 of file surface.py.

\hypertarget{classmedpy_1_1metric_1_1surface_1_1Surface_a56381bbc209cbd46954ebc49e38d266c}{
\index{medpy::metric::surface::Surface@{medpy::metric::surface::Surface}!GetMaskEdgePoints@{GetMaskEdgePoints}}
\index{GetMaskEdgePoints@{GetMaskEdgePoints}!medpy::metric::surface::Surface@{medpy::metric::surface::Surface}}
\subsubsection[{GetMaskEdgePoints}]{\setlength{\rightskip}{0pt plus 5cm}def medpy.metric.surface.Surface.GetMaskEdgePoints (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}}
\label{classmedpy_1_1metric_1_1surface_1_1Surface_a56381bbc209cbd46954ebc49e38d266c}
\begin{DoxyReturn}{Returns}
The edge points of the mask object. 
\end{DoxyReturn}


Definition at line 270 of file surface.py.

\hypertarget{classmedpy_1_1metric_1_1surface_1_1Surface_aa1286d971da183a1763d0756d35c90bd}{
\index{medpy::metric::surface::Surface@{medpy::metric::surface::Surface}!GetMaskReferenceNn@{GetMaskReferenceNn}}
\index{GetMaskReferenceNn@{GetMaskReferenceNn}!medpy::metric::surface::Surface@{medpy::metric::surface::Surface}}
\subsubsection[{GetMaskReferenceNn}]{\setlength{\rightskip}{0pt plus 5cm}def medpy.metric.surface.Surface.GetMaskReferenceNn (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}}
\label{classmedpy_1_1metric_1_1surface_1_1Surface_aa1286d971da183a1763d0756d35c90bd}
\begin{DoxyReturn}{Returns}
The distances of the nearest neighbours of all mask edge points to all reference edge points. 
\end{DoxyReturn}


Definition at line 239 of file surface.py.

\hypertarget{classmedpy_1_1metric_1_1surface_1_1Surface_aebdeff8c2d6391c37572e5a791ed40f8}{
\index{medpy::metric::surface::Surface@{medpy::metric::surface::Surface}!GetMaximumSymmetricSurfaceDistance@{GetMaximumSymmetricSurfaceDistance}}
\index{GetMaximumSymmetricSurfaceDistance@{GetMaximumSymmetricSurfaceDistance}!medpy::metric::surface::Surface@{medpy::metric::surface::Surface}}
\subsubsection[{GetMaximumSymmetricSurfaceDistance}]{\setlength{\rightskip}{0pt plus 5cm}def medpy.metric.surface.Surface.GetMaximumSymmetricSurfaceDistance (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}}
\label{classmedpy_1_1metric_1_1surface_1_1Surface_aebdeff8c2d6391c37572e5a791ed40f8}


Computes the maximum symmetric surface distance, also known as Hausdorff distance, between the two objects surfaces. 

\begin{DoxyReturn}{Returns}
the maximum symmetric surface distance in millimeters
\end{DoxyReturn}
For a perfect segmentation this distance is 0. This metric is sensitive to outliers and returns the true maximum error.

Metric definition: Let $S(A)$ denote the set of surface voxels of $A$. The shortest distance of an arbitrary voxel $v$ to $S(A)$ is defined as: \[ d(v,S(A)) = \min_{s_A\in S(A)} ||v-s_A|| \] where $||.||$ denotes the Euclidean distance. The maximum symmetric surface distance is then given by: \[ MSD(A,B) = \max \left\{ \max_{s_A\in S(A)} d(s_A,S(B)), \max_{s_B\in S(B)} d(s_B,S(A)), \right\} \] 

Definition at line 133 of file surface.py.

\hypertarget{classmedpy_1_1metric_1_1surface_1_1Surface_a7248264eca680d9c4d327961fd04c8be}{
\index{medpy::metric::surface::Surface@{medpy::metric::surface::Surface}!GetReferenceEdgePoints@{GetReferenceEdgePoints}}
\index{GetReferenceEdgePoints@{GetReferenceEdgePoints}!medpy::metric::surface::Surface@{medpy::metric::surface::Surface}}
\subsubsection[{GetReferenceEdgePoints}]{\setlength{\rightskip}{0pt plus 5cm}def medpy.metric.surface.Surface.GetReferenceEdgePoints (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}}
\label{classmedpy_1_1metric_1_1surface_1_1Surface_a7248264eca680d9c4d327961fd04c8be}
\begin{DoxyReturn}{Returns}
The edge points of the reference object. 
\end{DoxyReturn}


Definition at line 277 of file surface.py.

\hypertarget{classmedpy_1_1metric_1_1surface_1_1Surface_a1ddfc188d4a3c2e7bf3d9347fdec8b14}{
\index{medpy::metric::surface::Surface@{medpy::metric::surface::Surface}!GetReferenceMaskNn@{GetReferenceMaskNn}}
\index{GetReferenceMaskNn@{GetReferenceMaskNn}!medpy::metric::surface::Surface@{medpy::metric::surface::Surface}}
\subsubsection[{GetReferenceMaskNn}]{\setlength{\rightskip}{0pt plus 5cm}def medpy.metric.surface.Surface.GetReferenceMaskNn (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}}
\label{classmedpy_1_1metric_1_1surface_1_1Surface_a1ddfc188d4a3c2e7bf3d9347fdec8b14}
\begin{DoxyReturn}{Returns}
The distances of the nearest neighbours of all reference edge points to all mask edge points.
\end{DoxyReturn}
The underlying algorithm used for the scipy.spatial.KDTree implementation is based on: Sunil Arya, David M. Mount, Nathan S. Netanyahu, Ruth Silverman, and Angela Y. Wu. 1998. An optimal algorithm for approximate nearest neighbor searching fixed dimensions. J. ACM 45, 6 (November 1998), 891-\/923 

Definition at line 257 of file surface.py.

\hypertarget{classmedpy_1_1metric_1_1surface_1_1Surface_a43fc6c5bbe3af05e886341fc3cd6e4a6}{
\index{medpy::metric::surface::Surface@{medpy::metric::surface::Surface}!GetRootMeanSquareSymmetricSurfaceDistance@{GetRootMeanSquareSymmetricSurfaceDistance}}
\index{GetRootMeanSquareSymmetricSurfaceDistance@{GetRootMeanSquareSymmetricSurfaceDistance}!medpy::metric::surface::Surface@{medpy::metric::surface::Surface}}
\subsubsection[{GetRootMeanSquareSymmetricSurfaceDistance}]{\setlength{\rightskip}{0pt plus 5cm}def medpy.metric.surface.Surface.GetRootMeanSquareSymmetricSurfaceDistance (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}}
\label{classmedpy_1_1metric_1_1surface_1_1Surface_a43fc6c5bbe3af05e886341fc3cd6e4a6}


Computes the root mean square symmetric surface distance between the two objects surfaces. 

\begin{DoxyReturn}{Returns}
root mean square symmetric surface distance in millimeters
\end{DoxyReturn}
For a perfect segmentation this distance is 0. This metric punishes large deviations from the true contour stronger than the average symmetric surface distance.

Metric definition: Let $S(A)$ denote the set of surface voxels of $A$. The shortest distance of an arbitrary voxel $v$ to $S(A)$ is defined as: \[ d(v,S(A)) = \min_{s_A\in S(A)} ||v-s_A|| \] where $||.||$ denotes the Euclidean distance. The root mean square symmetric surface distance is then given by: \[ RMSD(A,B) = \sqrt{\frac{1}{|S(A)|+|S(B)|}} \times \sqrt{ \sum_{s_A\in S(A)} d^2(s_A,S(B)) + \sum_{s_B\in S(B)} d^2(s_B,S(A)) } \] 

Definition at line 171 of file surface.py.



The documentation for this class was generated from the following file:\begin{DoxyCompactItemize}
\item 
/home/omaier/Programming/Python/medpy/src/medpy/metric/surface.py\end{DoxyCompactItemize}
