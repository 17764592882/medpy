<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MedPy: /home/omaier/Programming/Python/medpy/src/medpy/application/viscous_eqsplit_premorphology.py Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MedPy&#160;<span id="projectnumber">b0.1</span></div>
   <div id="projectbrief">Medicalimageprocessinginpython</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_39b96f9c4012765d2b281918e9f3d34d.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_38eb81983c5e08a00adc0664db29ada6.html">medpy</a>      </li>
      <li class="navelem"><a class="el" href="dir_c5517966d86bcfb7cb507e4e9fa1040b.html">application</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">viscous_eqsplit_premorphology.py</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">#!/usr/bin/python</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="comment">##</span>
<a name="l00004"></a>00004 <span class="comment"># Executes morphological operations over a gradient image on different levels.</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="comment"># build-in modules</span>
<a name="l00007"></a>00007 <span class="keyword">import</span> argparse
<a name="l00008"></a>00008 <span class="keyword">import</span> logging
<a name="l00009"></a>00009 <span class="keyword">import</span> os
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment"># third-party modules</span>
<a name="l00012"></a>00012 <span class="keyword">import</span> scipy
<a name="l00013"></a>00013 <span class="keyword">from</span> numpy <span class="keyword">import</span> histogram
<a name="l00014"></a>00014 <span class="keyword">from</span> scipy.ndimage.morphology <span class="keyword">import</span> generate_binary_structure,\
<a name="l00015"></a>00015     iterate_structure, grey_closing
<a name="l00016"></a>00016 <span class="keyword">from</span> nibabel.loadsave <span class="keyword">import</span> load, save
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="comment"># path changes</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment"># own modules</span>
<a name="l00021"></a>00021 <span class="keyword">from</span> medpy.core <span class="keyword">import</span> Logger
<a name="l00022"></a>00022 <span class="keyword">from</span> medpy.utilities <span class="keyword">import</span> image_like
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment"># information</span>
<a name="l00026"></a>00026 __author__ = <span class="stringliteral">&quot;Oskar Maier&quot;</span>
<a name="l00027"></a>00027 __version__ = <span class="stringliteral">&quot;r0.3, 2011-12-13&quot;</span>
<a name="l00028"></a>00028 __email__ = <span class="stringliteral">&quot;oskar.maier@googlemail.com&quot;</span>
<a name="l00029"></a>00029 __status__ = <span class="stringliteral">&quot;Release&quot;</span>
<a name="l00030"></a>00030 __description__ = <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00031"></a>00031 <span class="stringliteral">                  Takes a gradient image as input and performs on various levels of its</span>
<a name="l00032"></a>00032 <span class="stringliteral">                  topographic representation morphological closing operations as required</span>
<a name="l00033"></a>00033 <span class="stringliteral">                  by the viscous watershed. This step is a pre-processing step that has</span>
<a name="l00034"></a>00034 <span class="stringliteral">                  to be followed by a standard watershed segmentation, but makes it</span>
<a name="l00035"></a>00035 <span class="stringliteral">                  behave as if the a viscous liquid was used.</span>
<a name="l00036"></a>00036 <span class="stringliteral">                  To separate the gradient image into different regions, its topography</span>
<a name="l00037"></a>00037 <span class="stringliteral">                  is considered and the morphological closing in applied to vertical</span>
<a name="l00038"></a>00038 <span class="stringliteral">                  slices of said topographical representation.</span>
<a name="l00039"></a>00039 <span class="stringliteral">                  To take into account the different range of intensity values (and</span>
<a name="l00040"></a>00040 <span class="stringliteral">                  therefore different heights of the topography) that can appear,</span>
<a name="l00041"></a>00041 <span class="stringliteral">                  a histogram of the images intensity values is created and subsequently</span>
<a name="l00042"></a>00042 <span class="stringliteral">                  equalized. This way the vertical slices are of different size but</span>
<a name="l00043"></a>00043 <span class="stringliteral">                  contain nearly exactely the same amount of pixels.</span>
<a name="l00044"></a>00044 <span class="stringliteral">                  This step becomes especially important when the input image contains</span>
<a name="l00045"></a>00045 <span class="stringliteral">                  very steep gradients, as may for example appear if a metal implant</span>
<a name="l00046"></a>00046 <span class="stringliteral">                  is inside the scan range (metal being of a high density and leading</span>
<a name="l00047"></a>00047 <span class="stringliteral">                  to very bright spots).</span>
<a name="l00048"></a>00048 <span class="stringliteral">                  The provided &#39;sections&#39; parameter determines the number of bin of the</span>
<a name="l00049"></a>00049 <span class="stringliteral">                  equalized histogram and therefore the number of slices in which the</span>
<a name="l00050"></a>00050 <span class="stringliteral">                  topography is split.</span>
<a name="l00051"></a>00051 <span class="stringliteral">                  The &#39;dsize&#39; parameter determines the sizxe of the biggest disc applied</span>
<a name="l00052"></a>00052 <span class="stringliteral">                  in the closing operation. In each subsequent slice a smaller disc is</span>
<a name="l00053"></a>00053 <span class="stringliteral">                  applied.</span>
<a name="l00054"></a>00054 <span class="stringliteral">                  The resulting image will be saved under the same name and type as the</span>
<a name="l00055"></a>00055 <span class="stringliteral">                  input image, only with an &#39;_viscous&#39; and its parameters as suffix.</span>
<a name="l00056"></a>00056 <span class="stringliteral">                  See &quot;The viscous watershed transform&quot; by Vachier, Corinne and Meyer,</span>
<a name="l00057"></a>00057 <span class="stringliteral">                  Fernand (Journal of Mathematical Imaging and Vision) for more details.</span>
<a name="l00058"></a>00058 <span class="stringliteral">                  &quot;&quot;&quot;</span>
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="comment"># code</span>
<a name="l00061"></a>00061 <span class="keyword">def </span>main():
<a name="l00062"></a>00062     <span class="comment"># parse cmd arguments</span>
<a name="l00063"></a>00063     parser = getParser()
<a name="l00064"></a>00064     parser.parse_args()
<a name="l00065"></a>00065     args = getArguments(parser)
<a name="l00066"></a>00066     
<a name="l00067"></a>00067     <span class="comment"># prepare logger</span>
<a name="l00068"></a>00068     logger = Logger.getInstance()
<a name="l00069"></a>00069     <span class="keywordflow">if</span> args.debug: logger.setLevel(logging.DEBUG)
<a name="l00070"></a>00070     <span class="keywordflow">elif</span> args.verbose: logger.setLevel(logging.INFO)
<a name="l00071"></a>00071     
<a name="l00072"></a>00072     logger.info(<span class="stringliteral">&#39;Selected viscous type is {}&#39;</span>.format(args.type))
<a name="l00073"></a>00073     
<a name="l00074"></a>00074     <span class="comment"># iterate over input images</span>
<a name="l00075"></a>00075     <span class="keywordflow">for</span> image <span class="keywordflow">in</span> args.images:
<a name="l00076"></a>00076         
<a name="l00077"></a>00077         <span class="comment"># get and prepare image data</span>
<a name="l00078"></a>00078         logger.info(<span class="stringliteral">&#39;Loading image {} using NiBabel...&#39;</span>.format(image))
<a name="l00079"></a>00079         image_gradient = load(image)
<a name="l00080"></a>00080         
<a name="l00081"></a>00081         <span class="comment"># get and prepare image data</span>
<a name="l00082"></a>00082         image_gradient_data = scipy.squeeze(image_gradient.get_data())
<a name="l00083"></a>00083         
<a name="l00084"></a>00084         logger.debug(<span class="stringliteral">&#39;Intensity range of gradient image is ({}, {})&#39;</span>.format(image_gradient_data.min(), image_gradient_data.max()))
<a name="l00085"></a>00085         
<a name="l00086"></a>00086         <span class="comment"># build output file name and check for its existence, if not in sections mode</span>
<a name="l00087"></a>00087         <span class="keywordflow">if</span> <span class="stringliteral">&#39;sections&#39;</span> != args.type:
<a name="l00088"></a>00088             <span class="comment"># build output file name</span>
<a name="l00089"></a>00089             image_viscous_name = args.folder + <span class="stringliteral">&#39;/&#39;</span> + image.split(<span class="stringliteral">&#39;/&#39;</span>)[-1][:-4] + <span class="stringliteral">&#39;_viscous_{}_sec_{}_ds_{}&#39;</span>.format(args.type, args.sections, args.dsize)
<a name="l00090"></a>00090             image_viscous_name += image.split(<span class="stringliteral">&#39;/&#39;</span>)[-1][-4:]
<a name="l00091"></a>00091         
<a name="l00092"></a>00092             <span class="comment"># check if output file exists</span>
<a name="l00093"></a>00093             <span class="keywordflow">if</span> <span class="keywordflow">not</span> args.force:
<a name="l00094"></a>00094                 <span class="keywordflow">if</span> os.path.exists(image_viscous_name):
<a name="l00095"></a>00095                     logger.warning(<span class="stringliteral">&#39;The output file {} already exists. Skipping this image.&#39;</span>.format(image_viscous_name))
<a name="l00096"></a>00096                     <span class="keywordflow">continue</span>
<a name="l00097"></a>00097                 
<a name="l00098"></a>00098 
<a name="l00099"></a>00099         <span class="comment"># execute plain closing i.e. a closing operation over the whole image, if in plain mode</span>
<a name="l00100"></a>00100         <span class="keywordflow">if</span> <span class="stringliteral">&#39;plain&#39;</span> == args.type:
<a name="l00101"></a>00101             <span class="comment"># prepare the disc structure (a ball with a diameter of (args.dsize * 2 + 1))</span>
<a name="l00102"></a>00102             disc = iterate_structure(generate_binary_structure(3, 1), args.dsize).astype(scipy.int_)
<a name="l00103"></a>00103             
<a name="l00104"></a>00104             <span class="comment"># apply closing</span>
<a name="l00105"></a>00105             logger.info(<span class="stringliteral">&#39;Applying the morphology over whole image at once...&#39;</span>)
<a name="l00106"></a>00106             image_viscous_data = grey_closing(image_gradient_data, footprint=disc)
<a name="l00107"></a>00107             
<a name="l00108"></a>00108             <span class="comment"># save resulting gradient image</span>
<a name="l00109"></a>00109             logger.info(<span class="stringliteral">&#39;Saving resulting gradient image as {}...&#39;</span>.format(image_viscous_name))
<a name="l00110"></a>00110             image_viscous = image_like(image_viscous_data, image_gradient)
<a name="l00111"></a>00111             save(image_viscous, image_viscous_name)
<a name="l00112"></a>00112             
<a name="l00113"></a>00113             <span class="comment"># skip other morphologies</span>
<a name="l00114"></a>00114             <span class="keywordflow">continue</span>
<a name="l00115"></a>00115         
<a name="l00116"></a>00116         
<a name="l00117"></a>00117         <span class="comment"># create gradient images flattened histogram</span>
<a name="l00118"></a>00118         bins = hist_flatened(image_gradient_data, args.sections)
<a name="l00119"></a>00119         logger.debug(<span class="stringliteral">&#39;{} bins created&#39;</span>.format(len(bins) - 1))
<a name="l00120"></a>00120         
<a name="l00121"></a>00121         <span class="comment"># check if the number of bins is consistent</span>
<a name="l00122"></a>00122         <span class="keywordflow">if</span> args.sections != len(bins) - 1:
<a name="l00123"></a>00123             <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&#39;Inconsistency between the number of requested and created bins ({} to {})&#39;</span>.format(args.sections, len(bins) - 1))
<a name="l00124"></a>00124         
<a name="l00125"></a>00125         <span class="comment"># prepare result file</span>
<a name="l00126"></a>00126         image_viscous_data = image_gradient_data
<a name="l00127"></a>00127         
<a name="l00128"></a>00128         <span class="comment"># transform the gradient images topography (Note: the content of one bin is: bins[slice - 1] &lt;= content &lt; bins[slice] </span>
<a name="l00129"></a>00129         logger.info(<span class="stringliteral">&#39;Applying the viscous morphological operations {} times...&#39;</span>.format(args.sections))
<a name="l00130"></a>00130         <span class="keywordflow">for</span> slice <span class="keywordflow">in</span> range(1, args.sections + 1):
<a name="l00131"></a>00131             
<a name="l00132"></a>00132             <span class="comment"># build output file name and check for its existence, if in sections mode</span>
<a name="l00133"></a>00133             <span class="keywordflow">if</span> <span class="stringliteral">&#39;sections&#39;</span> == args.type:
<a name="l00134"></a>00134                 <span class="comment"># build output file name</span>
<a name="l00135"></a>00135                 image_viscous_name = args.folder + <span class="stringliteral">&#39;/&#39;</span> + image.split(<span class="stringliteral">&#39;/&#39;</span>)[-1][:-4] + <span class="stringliteral">&#39;_viscous_{}_sec_{}_ds_{}_sl_{}&#39;</span>.format(args.type, args.sections, args.dsize, slice)
<a name="l00136"></a>00136                 image_viscous_name += image.split(<span class="stringliteral">&#39;/&#39;</span>)[-1][-4:]
<a name="l00137"></a>00137             
<a name="l00138"></a>00138                 <span class="comment"># check if output file exists</span>
<a name="l00139"></a>00139                 <span class="keywordflow">if</span> <span class="keywordflow">not</span> args.force:
<a name="l00140"></a>00140                     <span class="keywordflow">if</span> os.path.exists(image_viscous_name):
<a name="l00141"></a>00141                         logger.warning(<span class="stringliteral">&#39;The output file {} already exists. Skipping this slice.&#39;</span>.format(image_viscous_name))
<a name="l00142"></a>00142                         <span class="keywordflow">continue</span>
<a name="l00143"></a>00143                 
<a name="l00144"></a>00144                 <span class="comment"># prepare result file</span>
<a name="l00145"></a>00145                 image_viscous_data = image_gradient_data
<a name="l00146"></a>00146 
<a name="l00147"></a>00147             
<a name="l00148"></a>00148             <span class="comment"># create masks to extract the affected voxels (i.e. the current slice of the topographic image representation)</span>
<a name="l00149"></a>00149             mask_greater = (image_gradient_data &gt;= bins[slice]) <span class="comment"># all voxels with are over the current slice</span>
<a name="l00150"></a>00150             mask_lower = (image_gradient_data &lt; bins[slice - 1]) <span class="comment"># all voxels which are under the current slice</span>
<a name="l00151"></a>00151             mask_equal = scipy.invert(mask_greater | mask_lower) <span class="comment"># all voxels in the current slice</span>
<a name="l00152"></a>00152             <span class="keywordflow">if</span> <span class="stringliteral">&#39;mercury&#39;</span> == args.type:
<a name="l00153"></a>00153                 dsize = int((args.dsize / float(args.sections)) * (slice))
<a name="l00154"></a>00154                 disc = iterate_structure(generate_binary_structure(3, 1), dsize).astype(scipy.int_)
<a name="l00155"></a>00155                 mask_equal_or_greater = mask_equal | mask_greater
<a name="l00156"></a>00156                 image_threshold_data = image_gradient_data * mask_equal_or_greater
<a name="l00157"></a>00157             <span class="keywordflow">elif</span> <span class="stringliteral">&#39;oil&#39;</span> == args.type:
<a name="l00158"></a>00158                 dsize = int((args.dsize / float(args.sections)) * (args.sections - slice + 1))
<a name="l00159"></a>00159                 disc = iterate_structure(generate_binary_structure(3, 1), dsize).astype(scipy.int_)
<a name="l00160"></a>00160                 image_threshold_data = image_gradient_data.copy()
<a name="l00161"></a>00161                 mask_equal_or_lower = mask_equal | mask_lower
<a name="l00162"></a>00162                 <span class="comment"># set all voxels over the current slice to the max of all voxels in the current slice</span>
<a name="l00163"></a>00163                 image_threshold_data[mask_greater] = image_threshold_data[mask_equal_or_lower].max()
<a name="l00164"></a>00164             <span class="keywordflow">elif</span> <span class="stringliteral">&#39;sections&#39;</span> == args.type:
<a name="l00165"></a>00165                 dsize = args.dsize
<a name="l00166"></a>00166                 disc = iterate_structure(generate_binary_structure(3, 1), args.dsize).astype(scipy.int_)
<a name="l00167"></a>00167                 image_threshold_data = image_gradient_data.copy()
<a name="l00168"></a>00168                 <span class="comment"># set all voxels under the current slice to zero</span>
<a name="l00169"></a>00169                 image_threshold_data[mask_lower] = 0
<a name="l00170"></a>00170                 <span class="comment"># set all voxels over the current slice to the max of all voxels in the current slice</span>
<a name="l00171"></a>00171                 image_threshold_data[mask_greater] = image_threshold_data[mask_equal].max()
<a name="l00172"></a>00172 
<a name="l00173"></a>00173             logger.debug(<span class="stringliteral">&#39;{} of {} voxels belong to this level.&#39;</span>.format(len(mask_equal.nonzero()[0]), scipy.prod(image_threshold_data.shape)))            
<a name="l00174"></a>00174 
<a name="l00175"></a>00175             <span class="comment"># apply the closing with the appropriate disc size</span>
<a name="l00176"></a>00176             logger.debug(<span class="stringliteral">&#39;Applying a disk of {} to all values &gt;= {} and &lt; {}...&#39;</span>.format(dsize, bins[slice - 1],  bins[slice]))
<a name="l00177"></a>00177             image_closed_data = grey_closing(image_threshold_data, footprint=disc)
<a name="l00178"></a>00178             
<a name="l00179"></a>00179             <span class="comment"># add result of this slice to the general results</span>
<a name="l00180"></a>00180             image_viscous_data = scipy.maximum(image_viscous_data, image_closed_data)
<a name="l00181"></a>00181             
<a name="l00182"></a>00182             <span class="comment"># save created output file, if in sections mode</span>
<a name="l00183"></a>00183             <span class="keywordflow">if</span> <span class="stringliteral">&#39;sections&#39;</span> == args.type:
<a name="l00184"></a>00184                 <span class="comment"># save resulting gradient image</span>
<a name="l00185"></a>00185                 logger.info(<span class="stringliteral">&#39;Saving resulting gradient image as {}...&#39;</span>.format(image_viscous_name))
<a name="l00186"></a>00186                 image_viscous = image_like(image_viscous_data, image_gradient)
<a name="l00187"></a>00187                 save(image_viscous, image_viscous_name)
<a name="l00188"></a>00188             
<a name="l00189"></a>00189             
<a name="l00190"></a>00190         <span class="comment"># save created output file, if not in sections mode</span>
<a name="l00191"></a>00191         <span class="keywordflow">if</span> <span class="stringliteral">&#39;sections&#39;</span> != args.type:
<a name="l00192"></a>00192             <span class="comment"># save resulting gradient image</span>
<a name="l00193"></a>00193             logger.info(<span class="stringliteral">&#39;Saving resulting gradient image as {}...&#39;</span>.format(image_viscous_name))
<a name="l00194"></a>00194             image_viscous = image_like(image_viscous_data, image_gradient)
<a name="l00195"></a>00195             save(image_viscous, image_viscous_name)
<a name="l00196"></a>00196             
<a name="l00197"></a>00197     logger.info(<span class="stringliteral">&#39;Successfully terminated.&#39;</span>)
<a name="l00198"></a>00198       
<a name="l00199"></a>00199 <span class="keyword">def </span>getArguments(parser):
<a name="l00200"></a>00200     <span class="stringliteral">&quot;Provides additional validation of the arguments collected by argparse.&quot;</span>
<a name="l00201"></a>00201     <span class="keywordflow">return</span> parser.parse_args()
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 <span class="keyword">def </span>getParser():
<a name="l00204"></a>00204     <span class="stringliteral">&quot;Creates and returns the argparse parser object.&quot;</span>
<a name="l00205"></a>00205     parser = argparse.ArgumentParser(description=__description__)
<a name="l00206"></a>00206 
<a name="l00207"></a>00207     parser.add_argument(<span class="stringliteral">&#39;folder&#39;</span>, help=<span class="stringliteral">&#39;The folder to store the results in.&#39;</span>)
<a name="l00208"></a>00208     parser.add_argument(<span class="stringliteral">&#39;sections&#39;</span>, type=int, help=<span class="stringliteral">&#39;The number of sections to split the image into.&#39;</span>)
<a name="l00209"></a>00209     parser.add_argument(<span class="stringliteral">&#39;dsize&#39;</span>, type=int, help=<span class="stringliteral">&#39;The size of the biggest disc to apply. Note that this value is for each section divided through the section no. and rounded down to the next full integer.&#39;</span>)
<a name="l00210"></a>00210     parser.add_argument(<span class="stringliteral">&#39;images&#39;</span>, nargs=<span class="stringliteral">&#39;+&#39;</span>, help=<span class="stringliteral">&#39;One or more gradient images.&#39;</span>)
<a name="l00211"></a>00211     parser.add_argument(<span class="stringliteral">&#39;-t&#39;</span>, <span class="stringliteral">&#39;--type&#39;</span>, <span class="stringliteral">&#39;--viscous-type&#39;</span>, dest=<span class="stringliteral">&#39;type&#39;</span>, default=<span class="stringliteral">&#39;oil&#39;</span>, choices=[<span class="stringliteral">&#39;oil&#39;</span>, <span class="stringliteral">&#39;mercury&#39;</span>, <span class="stringliteral">&#39;plain&#39;</span>, <span class="stringliteral">&#39;sections&#39;</span>], help=<span class="stringliteral">&#39;Select the type of the morphological operation. oil behaves more liquid and less viscous in the higher intensity values, mercury in the lower and plain executes a single closing with a disk of the size of the supplied level parameter on the whole range and sections leads to an output image for each section. In the plain case the sections parameter is ignored.&#39;</span>)
<a name="l00212"></a>00212     parser.add_argument(<span class="stringliteral">&#39;-v&#39;</span>, dest=<span class="stringliteral">&#39;verbose&#39;</span>, action=<span class="stringliteral">&#39;store_true&#39;</span>, help=<span class="stringliteral">&#39;Display more information.&#39;</span>)
<a name="l00213"></a>00213     parser.add_argument(<span class="stringliteral">&#39;-d&#39;</span>, dest=<span class="stringliteral">&#39;debug&#39;</span>, action=<span class="stringliteral">&#39;store_true&#39;</span>, help=<span class="stringliteral">&#39;Display debug information.&#39;</span>)
<a name="l00214"></a>00214     parser.add_argument(<span class="stringliteral">&#39;-f&#39;</span>, dest=<span class="stringliteral">&#39;force&#39;</span>, action=<span class="stringliteral">&#39;store_true&#39;</span>, help=<span class="stringliteral">&#39;Silently override existing output images.&#39;</span>)
<a name="l00215"></a>00215     
<a name="l00216"></a>00216     <span class="keywordflow">return</span> parser
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="comment">##</span>
<a name="l00220"></a>00220 <span class="comment"># </span>
<a name="l00221"></a>00221 <span class="comment">#     @param im: the (gray-scale) image as numpy/scipy array</span>
<a name="l00222"></a>00222 <span class="comment">#     @param nbr_bins: the number of bins</span>
<a name="l00223"></a>00223 <span class="comment">#     @return: the bins of the flattened histogram of the image</span>
<a name="l00224"></a>00224 <span class="comment">#     </span>
<a name="l00225"></a>00225 <span class="keyword">def </span>hist_flatened(im,nbr_bins=10):
<a name="l00226"></a>00226     <span class="comment">#get image histogram</span>
<a name="l00227"></a>00227     imhist, bins = histogram(im.flatten(), 1000)
<a name="l00228"></a>00228     
<a name="l00229"></a>00229     <span class="comment"># only take bins with content into account</span>
<a name="l00230"></a>00230     nz = imhist.nonzero()
<a name="l00231"></a>00231     imhist = imhist[nz]
<a name="l00232"></a>00232     bins = bins[nz]
<a name="l00233"></a>00233     
<a name="l00234"></a>00234     <span class="comment"># prepare iteration</span>
<a name="l00235"></a>00235     bins_final = [bins[0]] <span class="comment"># set initial bin delimiter</span>
<a name="l00236"></a>00236     bins_content = scipy.prod(im.shape) / float(nbr_bins)
<a name="l00237"></a>00237     tmp_content = 0
<a name="l00238"></a>00238     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(imhist) - 1):
<a name="l00239"></a>00239         tmp_content += imhist[i]
<a name="l00240"></a>00240         <span class="keywordflow">if</span> tmp_content &gt;= bins_content: <span class="comment"># bin full</span>
<a name="l00241"></a>00241             <span class="comment">#bins_final.append(bins[i+1]) # add new bin delimiter</span>
<a name="l00242"></a>00242             <span class="comment">#tmp_content = 0</span>
<a name="l00243"></a>00243             div = float(imhist[i]) / (bins_content - (tmp_content - imhist[i])) <span class="comment"># what i got / what i want</span>
<a name="l00244"></a>00244             bins_final.append(bins[i] + (bins[i+1] - bins[i]) / div) <span class="comment"># append a partial bin border, assuming that the dist inside the bin in equal</span>
<a name="l00245"></a>00245             tmp_content = imhist[i] - (bins_content - (tmp_content - imhist[i]))
<a name="l00246"></a>00246             
<a name="l00247"></a>00247     bins_final.append(im.max() + 1) <span class="comment"># one added to work against rounding errors</span>
<a name="l00248"></a>00248         
<a name="l00249"></a>00249     <span class="keywordflow">return</span> bins_final
<a name="l00250"></a>00250     
<a name="l00251"></a>00251 <span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:
<a name="l00252"></a>00252     main()            
<a name="l00253"></a>00253     
<a name="l00254"></a>00254 
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 25 2012 13:44:15 for MedPy by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
